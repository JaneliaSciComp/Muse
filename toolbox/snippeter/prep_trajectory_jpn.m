function n=prep_trajectory_jpn(m, video_fc, m_per_pix)
% prep_trajectory: function to do some pre-processing on position data
%
% form: n=prep_trajectory(m)
%
% m is a struct with fields m_afX, m_afY, m_afA, m_afB, m_afTheta generated by SmartMouse
% time_offset is the offset in seconds of this file from the beginning of
% the experiment
%
% video_fc is the frame rate of the video
%
% m_per_pix is the conversion ratio between meters and pixels.  It is based
% on the video of the scale bar
%
% n is the same struct with the addition of x,y,a,b,theta and t fields
% x/y/a/b are m_afX/Y/A/B, converted from pixels to meters 
% and t is a length(x) vector with time bin values (assuming default of 30 Hz).
%
% note: A and B are radii, a and b are diameters, A/a are the long axis of
% the ellipse
%

% p==2 produces four structs, one for each mouse, with fields x,y,a,b,and
% theta, of length(m_afX), (element-by-element format for struct)
% this is really slow--you really don't want to do that

% defaults

% m_per_pix=.00098387;
% p=1;
n=m;
n.x=n.m_afX;%-min(n.m_afX); %used to shift the cage positions to 0 in x direction
n.y=n.m_afY;%-min(n.m_afY); %used to shift the cage positions to 0 in y direction
n.x_pix=n.x;
n.y_pix=n.y;
n.x=n.x*m_per_pix;
n.y=n.y*m_per_pix;
n.a=n.m_afA*m_per_pix*2; % A and B are radii, not diameters
n.b=n.m_afB*m_per_pix*2;
n.theta=n.m_afTheta;
n.t=1/video_fc:1/video_fc:length(n.x)/video_fc;

n.x=qinterp_jpn(n.x); % interpolate over any NaNs, qinterp is from AL
n.y=qinterp_jpn(n.y);

% n.spd=rvel_jpn(n,video_fc,video_fc*.2,2);

% if p==2
%     n=rmfield(n,'m_afX');
%     n=rmfield(n,'m_afY');
%     n=rmfield(n,'m_afA');
%     n=rmfield(n,'m_afB');
%     n=rmfield(n,'m_aTheta');
%     
%     field_names=fieldnames(n);
%     n=r_substruct(n,field_names,1:1:length(n.x));
%     
% end;
    
